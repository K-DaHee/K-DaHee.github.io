---
layout: post
title: "[자료구조] 힙(Heap)이란? - 완전 이진 트리와 우선순위 큐"
date: 2026-02-12 14:30:00 +0900
tags: [Algorithm, Data Structure, Heap, Priority Queue]
toc: true
---

# Heap (힙)

- **완전 이진 트리**를 기반으로 하는 트리 기반 자료구조
- **부모-자식 간의 규칙**을 따름
- **최댓값, 최솟값**을 빠르게 찾을 수 있음 ($O(1)$)
- **우선순위 큐**를 구현하는데 주로 사용
- **삽입, 삭제, 탐색 연산**을 효율적으로 수행 ($O(log N)$)

---

## 1. 종류: Max Heap & Min Heap

### Max Heap (최대 힙)
- 키 값이 가장 **큰** 노드를 찾기 위한 완전 이진 트리
- 특징: **부모 노드 ≥ 자식 노드**
- 루트 노드: **최댓값**을 가짐

### Min Heap (최소 힙)
- 키 값이 가장 **작은** 노드를 찾기 위한 완전 이진 트리
- 특징: **부모 노드 ≤ 자식 노드**
- 루트 노드: **최솟값**을 가짐

<br>

> ### ❓ 힙이 아닌 이유?
> 
> ![힙이 아닌 이유](/assets/images/heap/heap01.png)
> 
> - **트리 1**: 완전 이진 트리가 아니기 때문에 힙이라고 할 수 없다.
> - **트리 2**: 어떤 규칙(대소 관계)을 명확하게 만족시키지 못한다. 최소 힙인지 최대 힙인지 알 수 없다.

---

## 2. 힙의 연산 (시간 복잡도: $O(log N)$)

### 1) 삽입 연산 (Insertion)
데이터를 삽입할 때는 **가장 끝 위치**에 노드를 추가한 후, 부모 노드와 비교하며 제자리를 찾아 올라갑니다 (Up-Heap).

![삽입 연산 개요](/assets/images/heap/heap02.png)

**[Max Heap 삽입 과정]**
1. 완전 이진 트리의 마지막 노드에 새로운 값을 삽입한다.
2. 부모 노드와 비교한다.
3. **부모 노드 < 삽입된 노드**라면, 부모와 위치를 바꾼다 (Swap).
4. 조건을 만족하거나 루트에 도달할 때까지 2~3번을 반복한다.

![Max Heap 삽입 1단계](/assets/images/heap/heap03.png)
![Max Heap 삽입 2단계](/assets/images/heap/heap04.png)
![Max Heap 삽입 3단계](/assets/images/heap/heap05.png)
![Max Heap 삽입 4단계](/assets/images/heap/heap06.png)

<br>

### 2) 삭제 연산 (Deletion)
힙에서의 삭제는 주로 **루트 노드(최댓값 또는 최솟값)를 삭제**하는 것을 의미합니다.

![삭제 연산 개요](/assets/images/heap/heap07.png)

**[Max Heap 삭제 과정]**
1. 루트 노드(최댓값)를 삭제(반환)한다.
2. **가장 마지막 노드**를 루트 위치로 옮긴다.
3. 자식 노드들과 비교한다.
4. **부모 노드 < 자식 노드**라면, 더 큰 자식 노드와 위치를 바꾼다 (Down-Heap).
5. 조건을 만족하거나 리프 노드에 도달할 때까지 3~4번을 반복한다.

![Max Heap 삭제 1단계](/assets/images/heap/heap08.png)

---

## 3. Heap 구현과 응용

### Heap 구현 (Max Heap 기준)
주로 **배열(Array)**을 이용하여 구현합니다.
- 부모 인덱스: `i / 2`
- 왼쪽 자식 인덱스: `i * 2`
- 오른쪽 자식 인덱스: `i * 2 + 1`

![Heap 구현](/assets/images/heap/heap09.png)


### Priority Queue (우선순위 큐)
- **선입 선출(FIFO)**이 아닌, **자료의 우선순위**에 따라 출력 순서가 결정되는 큐.
- 구현 방법별 시간 복잡도 비교:
    - 배열: 삽입/삭제 중 하나가 $O(N)$
    - 연결 리스트: 삽입/삭제 중 하나가 $O(N)$
    - **Heap**: 삽입/삭제 모두 **$O(log N)$** (가장 효율적! ✅)

### Heap Sort (힙 정렬)
- 시간 복잡도: **$O(N log N)$**
- 과정:
    1. 정렬하고 싶은 모든 요소를 힙에 삽입한다. (Build Heap)
    2. 힙에서 순차적으로 값을 삭제(Pop)하여 배열에 담는다.

> **※ 주의**: 우선순위 큐 등을 사용할 때, 중간에 값을 다시 넣었다가 빼면 정렬 순서가 의도와 다르게 바뀔 수 있습니다.
